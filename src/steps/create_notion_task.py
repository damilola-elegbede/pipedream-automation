"""
Create Notion Task from Email

Creates Notion database entries from email data. Optionally renders HTML
email content as an image using the HTML/CSS to Image API.

Usage: Copy-paste into a Pipedream Python step
Required:
  - Connect Notion account with OAuth
  - Set NOTION_DATABASE_ID environment variable in Pipedream
  - Set HCTI_USER_ID and HCTI_API_KEY environment variables in Pipedream
"""
import os
import requests
import time
import re
import json

# --- Configuration ---
PREVIOUS_STEP_NAME = "gmail"
NOTION_API_VERSION = "2022-06-28"
MAX_CODE_BLOCK_LENGTH = 2000

# HTML/CSS to Image API Endpoint
HCTI_API_ENDPOINT = "https://hcti.io/v1/image"


def extract_email(email_string):
    """Extracts the email address from a string potentially containing a name."""
    if not email_string:
        return None
    match = re.search(r'<([^>]+)>', email_string)
    if match:
        return match.group(1)
    if '@' in email_string and '.' in email_string.split('@')[-1]:
        potential_email = email_string.split()[-1]
        if '@' in potential_email:
            return potential_email.strip('<>')
    if '@' in email_string:
        return email_string.strip()
    return None


def build_notion_properties(email_data, gmail_message_id):
    """Constructs the 'properties' dictionary for the Notion API request.

    Now includes Message ID property to enable duplicate detection.
    """
    properties = {}
    subject = email_data.get("subject", "No Subject")
    properties["Task name"] = {
        "title": [{"type": "text", "text": {"content": subject}}]
    }

    # Store Gmail Message ID for duplicate detection
    properties["Message ID"] = {
        "rich_text": [{"type": "text", "text": {"content": gmail_message_id}}]
    }

    url = email_data.get("url")
    if url:
        properties["Original Email Link"] = {"url": url}
    else:
        print(f"Warning: Missing 'url' for subject: {subject}")

    sender_raw = email_data.get("sender")
    sender_email = extract_email(sender_raw)
    if sender_email:
        properties["Sender"] = {"email": sender_email}
    else:
        print(f"Warning: Could not extract valid email from 'sender' for subject: {subject} (Raw: {sender_raw})")

    receiver_raw = email_data.get("receiver")
    receiver_email = extract_email(receiver_raw.split(',')[0]) if receiver_raw else None
    if receiver_email:
        properties["To"] = {"email": receiver_email}
    else:
        print(f"Warning: Could not extract valid email from 'receiver' for subject: {subject} (Raw: {receiver_raw})")
    return properties


def check_existing_task(headers, database_id, gmail_message_id):
    """Query Notion to check if task already exists for this email.

    Returns the existing page data if found, None otherwise.
    """
    query_url = f"https://api.notion.com/v1/databases/{database_id}/query"
    try:
        response = requests.post(
            query_url,
            headers=headers,
            json={
                "filter": {
                    "property": "Message ID",
                    "rich_text": {"equals": gmail_message_id}
                }
            },
            timeout=30
        )
        response.raise_for_status()
        results = response.json().get("results", [])
        if results:
            return results[0]
        return None
    except requests.exceptions.HTTPError as e:
        print(f"  Warning: Could not check for existing task: {e}")
        return None
    except Exception as e:
        print(f"  Warning: Error checking for existing task: {e}")
        return None


def get_image_url_from_html(html_content, hcti_user_id, hcti_api_key):
    """Calls HTML/CSS to Image API to render HTML and returns the image URL."""
    if not html_content:
        print("    No HTML content provided for image rendering.")
        return None
    if not hcti_user_id or not hcti_api_key:
        print("    Warning: HCTI credentials not configured. Set HCTI_USER_ID and HCTI_API_KEY environment variables in Pipedream.")
        return None

    data = {
        'html': html_content,
        'ms_delay': 1000
    }
    print(f"    Requesting image generation from HCTI. HTML length: {len(html_content)}. Delay: {data['ms_delay']}ms.")

    try:
        response = requests.post(
            url=HCTI_API_ENDPOINT,
            data=data,
            auth=(hcti_user_id, hcti_api_key),
            timeout=30
        )
        response.raise_for_status()
        image_data = response.json()
        image_url = image_data.get('url')

        if image_url and isinstance(image_url, str) and image_url.startswith('http') and 'hcti.io' in image_url:
            print(f"    Image URL successfully generated by HCTI: {image_url}")
            return image_url
        else:
            print(f"    HCTI API call succeeded but no valid image URL in response: {image_data}")
            return None
    except requests.exceptions.HTTPError as http_err:
        status_code_msg = 'N/A'
        response_text_msg = "No response text available."
        if http_err.response is not None:
            status_code_msg = str(http_err.response.status_code)
            response_text_msg = http_err.response.text
        print(f"    HTTP Error calling HTML/CSS to Image API: Status {status_code_msg}")
        print(f"    HCTI API Response: {response_text_msg}")
        return None
    except requests.exceptions.Timeout:
        print("    Timeout calling HTML/CSS to Image API.")
        return None
    except requests.exceptions.RequestException as e:
        print(f"    Network error calling HTML/CSS to Image API: {e}")
        return None
    except json.JSONDecodeError as e:
        print(f"    Error decoding JSON response from HCTI API: {e}")
        return None
    except Exception as e:
        print(f"    Unexpected error during image generation: {e}")
        return None


def build_page_content_blocks(plain_text_body, image_url_for_embed):
    """Constructs a list of Notion block objects including an embed for the image URL and plain text."""
    children_blocks = []

    # Add H2 Heading for HTML Image section (now an Embed)
    if image_url_for_embed and isinstance(image_url_for_embed, str) and image_url_for_embed.startswith('http'):
        print(f"    Image URL for Notion Embed block: {image_url_for_embed!r}")
        try:
            print(f"    Performing HEAD request to validate embed URL: {image_url_for_embed}")
            head_response = requests.head(image_url_for_embed, timeout=10, allow_redirects=True)
            content_type = head_response.headers.get('Content-Type')
            print(f"    HEAD request to embed URL successful. Status: {head_response.status_code}, Content-Type: {content_type}")
            if not content_type or not content_type.startswith('image/'):
                print(f"    Note: URL {image_url_for_embed} Content-Type is '{content_type}', not strictly 'image/*'. Embed block might still work.")
        except requests.exceptions.Timeout:
            print(f"    WARNING: Timeout performing HEAD request to embed URL {image_url_for_embed}.")
        except requests.exceptions.RequestException as e_head:
            print(f"    WARNING: Could not perform HEAD request to embed URL {image_url_for_embed}: {e_head}")

        children_blocks.append({
            "object": "block",
            "type": "heading_2",
            "heading_2": {
                "rich_text": [{"type": "text", "text": {"content": "HTML Image (Embedded)"}}]
            }
        })
        children_blocks.append({
            "object": "block",
            "type": "embed",
            "embed": {
                "url": image_url_for_embed
            }
        })
        children_blocks.append({
            "object": "block",
            "type": "divider",
            "divider": {}
        })
    elif image_url_for_embed:
        print(f"    Warning: Rendered image URL '{image_url_for_embed}' was not valid for Notion block. Skipping embed block.")
    else:
        print("    Info: No image URL provided or image generation failed. Skipping HTML Image (Embed) section.")

    # Add H2 Heading for Plain Text Body section
    if plain_text_body and plain_text_body.strip():
        children_blocks.append({
            "object": "block",
            "type": "heading_2",
            "heading_2": {
                "rich_text": [{"type": "text", "text": {"content": "Plain Text Body"}}]
            }
        })

        start_index = 0
        while start_index < len(plain_text_body):
            chunk = plain_text_body[start_index : start_index + MAX_CODE_BLOCK_LENGTH]
            children_blocks.append({
                "object": "block",
                "type": "code",
                "code": {
                    "rich_text": [{"type": "text", "text": {"content": chunk}}],
                    "language": "plain text"
                }
            })
            start_index += MAX_CODE_BLOCK_LENGTH
            if start_index < len(plain_text_body):
                print(f"    Plain text body is long, creating multiple code blocks. Current chunk ends at index {start_index-1}")

    elif plain_text_body:
        print("    Warning: Plain text body is empty or whitespace only. Skipping code block for plain text.")

    return children_blocks


def handler(pd: "pipedream"):
    # --- 1. Get Notion and HTML/CSS to Image API Credentials ---
    try:
        notion_token = pd.inputs["notion"]["$auth"]["oauth_access_token"]
    except KeyError:
        raise Exception("Notion account not connected or input name is not 'notion'. Please connect Notion using OAuth.")

    # Get Database ID from environment variable (required)
    database_id = os.environ.get("NOTION_DATABASE_ID")
    if not database_id:
        raise Exception("NOTION_DATABASE_ID environment variable not set. Set it in Pipedream Settings > Environment Variables")

    # Get HCTI credentials from environment variables
    hcti_user_id = os.environ.get("HCTI_USER_ID")
    hcti_api_key = os.environ.get("HCTI_API_KEY")

    if hcti_user_id and hcti_api_key:
        print("Using HCTI credentials from environment variables.")
    else:
        print("Warning: HCTI credentials not found in environment. Image generation will be skipped.")
        print("Set HCTI_USER_ID and HCTI_API_KEY in Pipedream Settings > Environment Variables")

    # --- 2. Get Email Data from Previous Step ---
    try:
        emails_to_process = pd.steps[PREVIOUS_STEP_NAME]["$return_value"]
    except KeyError:
        print(f"Error: Could not find return value from step '{PREVIOUS_STEP_NAME}'.")
        return {"error": f"Could not find data from step {PREVIOUS_STEP_NAME}", "successful_mappings": [], "errors": []}
    except Exception as e:
        print(f"An unexpected error occurred accessing previous step data: {e}")
        return {"error": "Failed to access previous step data.", "successful_mappings": [], "errors": []}

    if not emails_to_process:
        print("No email data received. Nothing to process.")
        return {"status": "No data received", "created_items": 0, "successful_mappings": [], "errors": []}
    if not isinstance(emails_to_process, list):
        print(f"Error: Expected a list from step '{PREVIOUS_STEP_NAME}', got {type(emails_to_process)}.")
        return {"error": "Invalid data format from previous step.", "successful_mappings": [], "errors": []}

    # --- 3. Prepare for Notion API Calls ---
    notion_pages_api_url = "https://api.notion.com/v1/pages"
    notion_blocks_api_url_base = "https://api.notion.com/v1/blocks/"
    headers = {
        "Authorization": f"Bearer {notion_token}",
        "Content-Type": "application/json",
        "Notion-Version": NOTION_API_VERSION,
    }

    successful_mappings = []
    errors = []
    skipped_duplicates = 0
    print(f"Starting to process {len(emails_to_process)} email(s) for Notion...")

    # --- 4. Loop Through Emails and Create Notion Items & Content ---
    for index, email_data in enumerate(emails_to_process):
        print(f"\nProcessing email {index + 1}/{len(emails_to_process)} (Subject: {email_data.get('subject', 'N/A')})...")

        if not isinstance(email_data, dict) or "message_id" not in email_data:
            print(f"  Skipping item {index + 1}: Invalid format or missing 'message_id'.")
            errors.append({"index": index + 1, "error": "Invalid item format or missing message_id"})
            continue

        gmail_message_id = email_data["message_id"]
        page_id = None
        rendered_image_url = None

        # --- Check for existing task (duplicate detection) ---
        existing_task = check_existing_task(headers, database_id, gmail_message_id)
        if existing_task:
            existing_page_id = existing_task.get("id")
            print(f"  Task already exists for message {gmail_message_id} (Page ID: {existing_page_id}). Skipping creation.")
            successful_mappings.append({
                "gmail_message_id": gmail_message_id,
                "notion_page_id": existing_page_id,
                "skipped": True,
                "reason": "duplicate"
            })
            skipped_duplicates += 1
            continue

        try:
            properties_payload = build_notion_properties(email_data, gmail_message_id)
            if "Task name" not in properties_payload:
                raise ValueError("Failed to generate 'Task name' property.")

            page_creation_body = {
                "parent": {"database_id": database_id},
                "properties": properties_payload,
            }
            print(f"  Sending request to create Notion page with properties: {json.dumps(properties_payload, indent=2)}")
            response_page = requests.post(notion_pages_api_url, headers=headers, json=page_creation_body)
            response_page.raise_for_status()
            created_page_data = response_page.json()
            page_id = created_page_data.get("id")
            print(f"  Successfully created Notion page: ID {page_id}")

            print(f"    Waiting for 2 seconds before appending content to page {page_id}...")
            time.sleep(2)

            html_to_render = email_data.get("html_body")
            if page_id and html_to_render and hcti_user_id and hcti_api_key:
                rendered_image_url = get_image_url_from_html(html_to_render, hcti_user_id, hcti_api_key)
                print(f"    Rendered Image URL obtained from HCTI service for embed: {rendered_image_url}")
            elif not html_to_render:
                print("    No HTML body found in email_data to render as image.")
            elif not (hcti_user_id and hcti_api_key):
                print("    HCTI credentials missing. Skipping image generation.")

            plain_text_content = email_data.get("plain_text_body", "")
            if page_id:
                content_blocks = build_page_content_blocks(plain_text_content, rendered_image_url)
                if content_blocks:
                    chunks = [content_blocks[i:i + 100] for i in range(0, len(content_blocks), 100)]
                    for chunk_idx, chunk_data in enumerate(chunks):
                        append_blocks_body = {"children": chunk_data}
                        print(f"    Appending content blocks (chunk {chunk_idx + 1}/{len(chunks)}) to page ID: {page_id}")
                        try:
                            print(f"    Attempting to send blocks payload: {json.dumps(append_blocks_body, indent=2)}")
                        except Exception as json_e:
                            print(f"    Could not serialize append_blocks_body for logging: {json_e}")
                            print(f"    Raw append_blocks_body (may be large): {append_blocks_body}")

                        blocks_url = f"{notion_blocks_api_url_base}{page_id}/children"
                        response_blocks = requests.patch(blocks_url, headers=headers, json=append_blocks_body)
                        response_blocks.raise_for_status()
                        print(f"    Successfully appended content blocks (chunk {chunk_idx + 1}).")
                        if len(chunks) > 1:
                            time.sleep(0.3)
                else:
                    print("    No content blocks (text or image) to append.")
            else:
                print("    Page ID not available, skipping content append.")

            successful_mappings.append({
                "gmail_message_id": gmail_message_id,
                "notion_page_id": page_id,
                "rendered_image_url": rendered_image_url
            })

        except requests.exceptions.HTTPError as http_err:
            status_code_str = 'N/A'
            error_message = str(http_err)
            error_details = {}
            validation_errors = None

            if http_err.response is not None:
                status_code_str = str(http_err.response.status_code)
                try:
                    if 'application/json' in http_err.response.headers.get('Content-Type', ''):
                        error_details = http_err.response.json()
                        error_message = error_details.get('message', str(http_err))
                        validation_errors = error_details.get('validation_errors')
                    else:
                        error_details = {"raw_response": http_err.response.text}
                        error_message = http_err.response.text if http_err.response.text else str(http_err)
                except json.JSONDecodeError:
                    error_details = {"raw_response": http_err.response.text}
                    error_message = f"Failed to decode JSON response. Raw text: {http_err.response.text}"
                except Exception as e_resp:
                    error_message = f"Error processing HTTPError response: {e_resp}"
                    error_details = {"processing_error": str(e_resp)}

            print(f"  HTTP Error for Gmail ID {gmail_message_id}: {status_code_str} - {error_message}")
            if validation_errors:
                print(f"  Validation Errors: {json.dumps(validation_errors, indent=2)}")
            elif error_details:
                print(f"  Error Details: {json.dumps(error_details, indent=2)}")

            errors.append({
                "index": index + 1, "gmail_message_id": gmail_message_id,
                "subject": email_data.get('subject'), "status_code": status_code_str,
                "error": error_message, "validation_errors": validation_errors, "raw_error_details": error_details,
                "notion_page_id_attempted": page_id
            })
        except Exception as e:
            print(f"  An unexpected error for Gmail ID {gmail_message_id}: {e}")
            errors.append({
                "index": index + 1, "gmail_message_id": gmail_message_id,
                "subject": email_data.get('subject'), "error": f"Unexpected error: {e}",
                "notion_page_id_attempted": page_id
            })
        time.sleep(0.5)

    # --- 5. Return Summary (ALWAYS include successful_mappings) ---
    status = "Completed" if not errors else "Partial"
    print("\n--- Processing Complete ---")
    print(f"Successfully processed items: {len(successful_mappings)}")
    print(f"Skipped duplicates: {skipped_duplicates}")
    print(f"Errors encountered: {len(errors)}")
    return {
        "status": status,
        "total_processed": len(emails_to_process),
        "successful_mappings": successful_mappings,
        "skipped_duplicates": skipped_duplicates,
        "errors": errors
    }
